package main

// ----- ---- --- -- -
// Copyright 2019, 2020 The Axiom Foundation. All Rights Reserved.
//
// Licensed under the Apache License 2.0 (the "License").  You may not use
// this file except in compliance with the License.  You can obtain a copy
// in the file LICENSE in the source distribution or at
// https://www.apache.org/licenses/LICENSE-2.0.txt
// - -- --- ---- -----

/*

Notes:

* goroutines are required in each of the handlers to prevent Go from flagging the program as deadlocked.
* This WASM module loads into the javascriprt engine like a separate application, rather like a server. It does not import a library, like a normal javascript module would.
* Panics will shut down the wasm application and it will not automatically restart. @TODO, add a line to report a panic.
* There is a global javascript function KeyaddrErrorHandler that can be overriden before this WASM module is loaded.
* There are three different levels of errors here
	* Panics which are avoided by code and should not ever occur. A @todo is mentioned above to handle reporting for this case.
	* Errors that are sent back through the callback. They are given as the first argument in the node-style
		callbacks, which `promisify` can put into promises, which can be handled with chained `.catch()` methods
		or the `try`/`catch` blocks.
	* Application level errors that cannot be sent to a callback. This can be because a callback was not provided, or an error occured that prevented a callback from being used. `dispatchError` and `KeyaddrErrorHandler` is used for these cases.

*/

import (
	"syscall/js"
)

// waitChannel is used to control keeping the process open, as well as closing on command.
var waitChannel chan struct{}

func main() {
	waitChannel = make(chan struct{})

	// put go functions in a javascript object
	obj := map[string]interface{}{
		"newKey":            js.FuncOf(newKey),
		"wordsToBytes":      js.FuncOf(wordsToBytes),
		"deriveFrom":        js.FuncOf(deriveFrom),
		"ndauAddress":       js.FuncOf(ndauAddress),
		"toPublic":          js.FuncOf(toPublic),
		"child":             js.FuncOf(child),
		"sign":              js.FuncOf(sign),
		"signEdB64":         js.FuncOf(signEdB64),
		"signEdText":        js.FuncOf(signEdText),
		"hardenedChild":     js.FuncOf(hardenedChild),
		"wordsFromPrefix":   js.FuncOf(wordsFromPrefix),
		"isPrivate":         js.FuncOf(isPrivate),
		"wordsFromBytes":    js.FuncOf(wordsFromBytes),
		"fromString":        js.FuncOf(fromString),
		"newEdKey":          js.FuncOf(newEdKey),
		"newEdKeyFromSeed":  js.FuncOf(newEdKeyFromSeed),
		"addrFromPublicKey": js.FuncOf(addrFromPublicKey),
		"exit":              js.FuncOf(exit),
	}

	// Register all functions globally under KeyaddrNS. Either `window` in browsers, or
	// `global` in node. NS stands for node style and refers to the functions which use
	// callbacks instead of promises. In node, the functions may be easily turned into
	// promisified functions with `util.promisify`.
	js.Global().Set("KeyaddrNS", js.ValueOf(obj))

	// Give the JS environment some constants to set the log level
	js.Global().Set("KeyaddrLogLevelDebug", js.ValueOf(levelDebug))
	js.Global().Set("KeyaddrLogLevelInfo", js.ValueOf(levelInfo))
	js.Global().Set("KeyaddrLogLevelError", js.ValueOf(levelError))

	// Set the log level to info if not already set
	if js.Global().Get("KeyaddrLogLevel").Type() == js.TypeUndefined {
		js.Global().Set("KeyaddrLogLevel", js.ValueOf(levelInfo))
	}

	// register default error handler if error handler doesn't already exist
	if js.Global().Get("KeyaddrErrorHandler").Truthy() == false {
		js.Global().Get("console").Call("log", "Global function KeyaddrErrorHandler not detected. Adding default error handler function. To override, instantiate KeyaddrErrorHandler early in the JS code.")
		js.Global().Set("KeyaddrErrorHandler", js.FuncOf(errorHandler))
	}

	<-waitChannel // wait indefinitely

	js.Global().Get("console").Call("log", "WASM Keyadder exiting")
}
